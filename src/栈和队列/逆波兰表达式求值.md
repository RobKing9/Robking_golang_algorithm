# [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

## 题目

根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

注意 两个整数之间的除法只保留整数部分。

可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

```
示例 1：

输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
示例 2：

输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
示例 3：

输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

提示：

- 1 <= tokens.length <= 104
- tokens[i] 是一个算符（"+"、"-"、"*" 或 "/"），或是在范围 [-200, 200] 内的一个整数

## 思路

方法：数组模拟栈

主要思路：开始的时候维护一个栈，遍历数组，将每个元素加入栈，如果是字符，将对 栈顶及前一个数做运算，运算可以封装一个函数处理，处理完之后将两个数pop，将结果push进去；如果是数字直接push到辅助栈；

细节：

- 开始的时候，维护栈元素类型为int，结果也为int，避免string和int转换导致不可预知的错误；
- 运算符没有必要push进去；
- 两个数pop取出来的时候注意顺序，栈顶应当是被除数/被减数

## 代码

```golang
func evalRPN(tokens []string) int {
    arr := make([]int,0)
    var res int
    //遍历数组
    for _, v := range tokens {
        //如果是字符 将两个数pop出来进行计算
        if v=="+" || v=="-" || v=="*" || v=="/" {
            //pop两个数 怎么取出来？--维护一个栈
            //栈顶
            b := arr[len(arr)-1]
            //栈顶前
            a := arr[len(arr)-2]
            res = handle(a, b, v)
            arr = arr[:len(arr)-2]
            arr = append(arr,res)
        } else {
            //是数字加入栈
            vv,_ := strconv.Atoi(v)
            arr = append(arr, vv)
        }
    }
    return arr[0]
}

func handle(x, y int, token string) int {
    if token=="+" {
        return x+y
    }
    if token=="-" {
        return x-y
    }
    if token=="*" {
        return x*y
    }
    if token=="/" {
        return x/y
    }
    return -1
}
```

